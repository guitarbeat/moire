/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/script.js":
/*!***********************!*\
  !*** ./src/script.js ***!
  \***********************/
/***/ (() => {

eval("function App() {\n  var _ogl = ogl,\n    Renderer = _ogl.Renderer,\n    Camera = _ogl.Camera,\n    Geometry = _ogl.Geometry,\n    Program = _ogl.Program,\n    Mesh = _ogl.Mesh,\n    Color = _ogl.Color,\n    Vec2 = _ogl.Vec2;\n  var renderer, gl, camera;\n  var width, height, wWidth, wHeight;\n  var mouse,\n    mouseOver = false;\n  var gridWidth, gridHeight, gridRatio;\n  // let gridWWidth, gridWHeight;\n  var ripple, points;\n  var color1 = new Color([0.149, 0.141, 0.912]);\n  var color2 = new Color([1.000, 0.833, 0.224]);\n  var cameraZ = 50;\n  init();\n  function init() {\n    renderer = new Renderer({\n      dpr: 1\n    });\n    gl = renderer.gl;\n    document.body.appendChild(gl.canvas);\n    camera = new Camera(gl, {\n      fov: 45\n    });\n    camera.position.set(0, 0, cameraZ);\n    resize();\n    window.addEventListener('resize', resize, false);\n    mouse = new Vec2();\n    initScene();\n    initEventsListener();\n    requestAnimationFrame(animate);\n  }\n  function initScene() {\n    gl.clearColor(1, 1, 1, 1);\n    ripple = new RippleEffect(renderer);\n    // randomizeColors();\n    initPointsMesh();\n  }\n  function initPointsMesh() {\n    gridWidth = width;\n    gridHeight = height;\n    // gridWWidth = gridWidth * wWidth / width;\n    // gridWHeight = gridHeight * wHeight / height;\n\n    var ssize = 3; // screen space\n    var wsize = ssize * wWidth / width;\n    var nx = Math.floor(gridWidth / ssize) + 1;\n    var ny = Math.floor(gridHeight / ssize) + 1;\n    var numPoints = nx * ny;\n    var ox = -wsize * (nx / 2 - 0.5),\n      oy = -wsize * (ny / 2 - 0.5);\n    var positions = new Float32Array(numPoints * 3);\n    var uvs = new Float32Array(numPoints * 2);\n    var sizes = new Float32Array(numPoints);\n    var uvx, uvy, uvdx, uvdy;\n    gridRatio = gridWidth / gridHeight;\n    if (gridRatio >= 1) {\n      uvx = 0;\n      uvdx = 1 / nx;\n      uvy = (1 - 1 / gridRatio) / 2;\n      uvdy = 1 / ny / gridRatio;\n    } else {\n      uvx = (1 - 1 * gridRatio) / 2;\n      uvdx = 1 / nx * gridRatio;\n      uvy = 0;\n      uvdy = 1 / ny;\n    }\n    for (var i = 0; i < nx; i++) {\n      var x = ox + i * wsize;\n      for (var j = 0; j < ny; j++) {\n        var i1 = i * ny + j,\n          i2 = i1 * 2,\n          i3 = i1 * 3;\n        var y = oy + j * wsize;\n        positions.set([x, y, 0], i3);\n        uvs.set([uvx + i * uvdx, uvy + j * uvdy], i2);\n        sizes[i1] = ssize / 2;\n      }\n    }\n    var geometry = new Geometry(gl, {\n      position: {\n        size: 3,\n        data: positions\n      },\n      uv: {\n        size: 2,\n        data: uvs\n      },\n      size: {\n        size: 1,\n        data: sizes\n      }\n    });\n    if (points) {\n      points.geometry = geometry;\n    } else {\n      var program = new Program(gl, {\n        uniforms: {\n          hmap: {\n            value: ripple.gpgpu.read.texture\n          },\n          color1: {\n            value: color1\n          },\n          color2: {\n            value: color2\n          }\n        },\n        vertex: \"\\n          precision highp float;\\n          const float PI = 3.1415926535897932384626433832795;\\n          uniform mat4 modelViewMatrix;\\n          uniform mat4 projectionMatrix;\\n          uniform sampler2D hmap;\\n          uniform vec3 color1;\\n          uniform vec3 color2;\\n          attribute vec2 uv;\\n          attribute vec3 position;\\n          attribute float size;\\n          varying vec4 vColor;\\n          void main() {\\n              vec3 pos = position.xyz;\\n              vec4 htex = texture2D(hmap, uv);\\n              pos.z = 10. * htex.r;\\n\\n              vec3 mixPct = vec3(0.0);\\n              mixPct.r = smoothstep(0.0, 0.5, htex.r);\\n              mixPct.g = sin(htex.r * PI);\\n              mixPct.b = pow(htex.r, 0.5);\\n              vColor = vec4(mix(color1, color2, mixPct), 1.0);\\n\\n              gl_PointSize = size;\\n              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n          }\\n        \",\n        fragment: \"\\n          precision highp float;\\n          varying vec4 vColor;\\n          void main() {\\n            gl_FragColor = vColor;\\n          }\\n        \"\n      });\n      points = new Mesh(gl, {\n        geometry: geometry,\n        program: program,\n        mode: gl.POINTS\n      });\n    }\n  }\n  function animate(t) {\n    requestAnimationFrame(animate);\n    camera.position.z += (cameraZ - camera.position.z) * 0.02;\n    if (!mouseOver) {\n      var time = Date.now() * 0.001;\n      var x = Math.cos(time) * 0.2;\n      var y = Math.sin(time) * 0.2;\n      ripple.addDrop(x, y, 0.05, 0.05);\n    }\n    ripple.update();\n    // ripple.update();\n    renderer.render({\n      scene: points,\n      camera: camera\n    });\n  }\n  function randomizeColors() {\n    color1.set(chroma.random().hex());\n    color2.set(chroma.random().hex());\n  }\n  function initEventsListener() {\n    if ('ontouchstart' in window) {\n      document.body.addEventListener('touchstart', onMove, false);\n      document.body.addEventListener('touchmove', onMove, false);\n      document.body.addEventListener('touchend', function () {\n        mouseOver = false;\n      }, false);\n    } else {\n      document.body.addEventListener('mousemove', onMove, false);\n      document.body.addEventListener('mouseleave', function () {\n        mouseOver = false;\n      }, false);\n      document.body.addEventListener('mouseup', randomizeColors, false);\n      document.addEventListener('scroll', function (e) {\n        cameraZ = 50 - getScrollPercentage() * 3;\n      });\n    }\n  }\n  function getScrollPercentage() {\n    var topPos = document.documentElement.scrollTop;\n    var remaining = document.documentElement.scrollHeight - document.documentElement.clientHeight;\n    return topPos / remaining;\n  }\n  function onMove(e) {\n    mouseOver = true;\n    if (e.changedTouches && e.changedTouches.length) {\n      e.x = e.changedTouches[0].pageX;\n      e.y = e.changedTouches[0].pageY;\n    }\n    if (e.x === undefined) {\n      e.x = e.pageX;\n      e.y = e.pageY;\n    }\n    mouse.set(e.x / gl.renderer.width * 2 - 1, (1.0 - e.y / gl.renderer.height) * 2 - 1);\n    if (gridRatio >= 1) {\n      mouse.y = mouse.y / gridRatio;\n    } else {\n      mouse.x = mouse.x / gridRatio;\n    }\n    ripple.addDrop(mouse.x, mouse.y, 0.05, 0.05);\n  }\n  function resize() {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    renderer.setSize(width, height);\n    camera.perspective({\n      aspect: width / height\n    });\n    var wSize = getWorldSize(camera);\n    wWidth = wSize[0];\n    wHeight = wSize[1];\n    if (points) initPointsMesh();\n  }\n  function getWorldSize(cam) {\n    var vFOV = cam.fov * Math.PI / 180;\n    var height = 2 * Math.tan(vFOV / 2) * Math.abs(cam.position.z);\n    var width = height * cam.aspect;\n    return [width, height];\n  }\n}\n\n/**\n * Ripple effect\n */\nvar RippleEffect = function () {\n  var _ogl2 = ogl,\n    Vec2 = _ogl2.Vec2,\n    Program = _ogl2.Program,\n    defaultVertex = \"attribute vec2 uv, position; varying vec2 vUv; void main() {vUv = uv; gl_Position = vec4(position, 0, 1);}\";\n  function RippleEffect(renderer) {\n    var width = 512,\n      height = 512;\n    Object.assign(this, {\n      renderer: renderer,\n      gl: renderer.gl,\n      width: width,\n      height: height,\n      delta: new Vec2(1 / width, 1 / height),\n      gpgpu: new GPGPU(renderer.gl, {\n        width: width,\n        height: height\n      })\n    });\n    this.initShaders();\n  }\n  RippleEffect.prototype.initShaders = function () {\n    this.updateProgram = new Program(this.gl, {\n      uniforms: {\n        tDiffuse: {\n          value: null\n        },\n        uDelta: {\n          value: this.delta\n        }\n      },\n      vertex: defaultVertex,\n      fragment: \"precision highp float; uniform sampler2D tDiffuse; uniform vec2 uDelta; varying vec2 vUv; void main() {vec4 texel = texture2D(tDiffuse, vUv); vec2 dx = vec2(uDelta.x, 0.0), dy = vec2(0.0, uDelta.y); float average = (texture2D(tDiffuse, vUv - dx).r + texture2D(tDiffuse, vUv - dy).r + texture2D(tDiffuse, vUv + dx).r + texture2D(tDiffuse, vUv + dy).r) * 0.25; texel.g += (average - texel.r) * 2.0; texel.g *= 0.8; texel.r += texel.g; gl_FragColor = texel;}\"\n    });\n    this.dropProgram = new Program(this.gl, {\n      uniforms: {\n        tDiffuse: {\n          value: null\n        },\n        uCenter: {\n          value: new Vec2()\n        },\n        uRadius: {\n          value: 0.05\n        },\n        uStrength: {\n          value: 0.05\n        }\n      },\n      vertex: defaultVertex,\n      fragment: \"precision highp float; const float PI = 3.1415926535897932384626433832795; uniform sampler2D tDiffuse; uniform vec2 uCenter; uniform float uRadius; uniform float uStrength; varying vec2 vUv; void main() {vec4 texel = texture2D(tDiffuse, vUv); float drop = max(0.0, 1.0 - length(uCenter * 0.5 + 0.5 - vUv) / uRadius); drop = 0.5 - cos(drop * PI) * 0.5; texel.r += drop * uStrength; gl_FragColor = texel;}\"\n    });\n  };\n  RippleEffect.prototype.update = function () {\n    this.updateProgram.uniforms.tDiffuse.value = this.gpgpu.read.texture;\n    this.gpgpu.renderProgram(this.updateProgram);\n  };\n  RippleEffect.prototype.addDrop = function (x, y, radius, strength) {\n    var us = this.dropProgram.uniforms;\n    us.tDiffuse.value = this.gpgpu.read.texture;\n    us.uCenter.value.set(x, y);\n    us.uRadius.value = radius;\n    us.uStrength.value = strength;\n    this.gpgpu.renderProgram(this.dropProgram);\n  };\n  return RippleEffect;\n}();\n\n/**\n * GPGPU Helper\n */\nvar GPGPU = function () {\n  var _ogl3 = ogl,\n    RenderTarget = _ogl3.RenderTarget,\n    Triangle = _ogl3.Triangle,\n    Mesh = _ogl3.Mesh;\n  function GPGPU(gl, _ref) {\n    var width = _ref.width,\n      height = _ref.height,\n      type = _ref.type;\n    Object.assign(this, {\n      gl: gl,\n      width: width,\n      height: height,\n      numVertexes: width * height,\n      read: new RenderTarget(gl, rto(gl, width, height, type)),\n      write: new RenderTarget(gl, rto(gl, width, height, type)),\n      mesh: new Mesh(gl, {\n        geometry: new Triangle(gl)\n      })\n    });\n  }\n  var rto = function rto(gl, width, height, type) {\n    return {\n      width: width,\n      height: height,\n      type: type || gl.HALF_FLOAT || gl.renderer.extensions[\"OES_texture_half_float\"].HALF_FLOAT_OES,\n      internalFormat: gl.renderer.isWebgl2 ? type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F : gl.RGBA,\n      depth: false,\n      unpackAlignment: 1\n    };\n  };\n  GPGPU.prototype.renderProgram = function (program) {\n    this.mesh.program = program;\n    this.gl.renderer.render({\n      scene: this.mesh,\n      target: this.write,\n      clear: false\n    });\n    this.swap();\n  };\n  GPGPU.prototype.swap = function () {\n    var _ref2 = [this.write, this.read];\n    this.read = _ref2[0];\n    this.write = _ref2[1];\n  };\n  return GPGPU;\n}();\nApp();\n\n//# sourceURL=webpack://moire/./src/script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/script.js"]();
/******/ 	
/******/ })()
;